<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Adding meta -->
    

    <!-- Adding external script-->
    

    <!-- Adding external style-->
    

    <!-- Adding scripts-->
    

    <!-- Adding style-->
    

    <!-- Adding overlay script-->
    

    <!-- Adding overlay style-->
    


    <title>
      schema-markdown/markdown.js
    </title>

    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/third-party/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/third-party/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/reset.css">
    <link type="text/css" rel="stylesheet" href="styles/heading.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-base.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-light.css">
    
    <svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
    style="display:none">
    <defs>
        <symbol id="copy-icon" viewbox="0 0 488.3 488.3">
            <g>
                <path
                    d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z" />
                <path
                    d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z" />
            </g>
        </symbol>
        <symbol id='search-icon' viewBox="0 0 512 512">
            <g>
                <g>
                    <path
                        d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z" />
                </g>
            </g>
            <g>
                <g>
                    <path
                        d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z" />
                </g>
            </g>
        </symbol>
        <symbol id="down-icon" viewBox="0 0 16 16">
            <path 
                fill-rule="evenodd" 
                clip-rule="evenodd" 
                d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"
            >
            </path>
        </symbol>
    </defs>
</svg>
  </head>

  <body>

    <nav class="navbar" id="navbar">
      <div class="navbar-heading" id="navbar-heading"><a href="index.html"><h2 class="navbar-heading-text">Home</h2></a></div><div class="search-box" id="search-box"><div class="search-box-input-container"><input class="search-box-input" type="text" placeholder="Search..." id="search-box-input" /><svg class="search-icon" alt="search-icon"><use xlink:href="#search-icon"></use></svg></div><div class="search-item-container" id="search-item-container"><ul class="search-item-ul" id="search-item-ul"></ul></div></div><div class="sidebar-main-content" id="sidebar-main-content"><ul><li class="menu-li"><a href='doc#name=TypeModel' class=' menu-link' id='' target=''>Type Model</a></li></ul><div class="accordion collapsed" id="549282" > <h3 class="accordion-heading">Classes<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion collapsed child" id=3043904><div class="accordion-heading child"><a href="module-doc.UserTypeElements.html">UserTypeElements</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="module-doc.UserTypeElements.html#.getUrlNoteElements">getUrlNoteElements</a></li><li data-type='method'><a href="module-doc.UserTypeElements.html#.markdownElem">markdownElem</a></li><li data-type='method'><a href="module-doc.UserTypeElements.html#getElements">getElements</a></li></ul></li><li class="accordion collapsed child" id=2192030><div class="accordion-heading child"><a href="module-parser.SchemaMarkdownParser.html">SchemaMarkdownParser</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="module-parser.SchemaMarkdownParser.html#finalize">finalize</a></li><li data-type='method'><a href="module-parser.SchemaMarkdownParser.html#parse">parse</a></li><li data-type='method'><a href="module-parser.SchemaMarkdownParser.html#parseString">parseString</a></li></ul></li><li class="accordion-list" id=""><a href="module-parser-SchemaMarkdownParserError.html">SchemaMarkdownParserError</a></li></ul> </div><div class="accordion collapsed" id="6400196" > <h3 class="accordion-heading">Modules<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion-list" id=""><a href="module-doc.html">doc</a></li><li class="accordion collapsed child" id=9633893><div class="accordion-heading child"><a href="module-elements.html">elements</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="module-elements.html#.getBaseURL">getBaseURL</a></li><li data-type='method'><a href="module-elements.html#.isAbsoluteURL">isAbsoluteURL</a></li><li data-type='method'><a href="module-elements.html#.renderElements">renderElements</a></li><li data-type='method'><a href="module-elements.html#.validateElements">validateElements</a></li></ul></li><li class="accordion collapsed child" id=4442406><div class="accordion-heading child"><a href="module-encode.html">encode</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="module-encode.html#.decodeQueryString">decodeQueryString</a></li><li data-type='method'><a href="module-encode.html#.encodeHref">encodeHref</a></li><li data-type='method'><a href="module-encode.html#.encodeQueryString">encodeQueryString</a></li></ul></li><li class="accordion collapsed child" id=3944399><div class="accordion-heading child"><a href="module-markdown.html">markdown</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="module-markdown.html#.markdownElements">markdownElements</a></li><li data-type='method'><a href="module-markdown.html#.markdownParse">markdownParse</a></li></ul></li><li class="accordion-list" id=""><a href="module-parser.html">parser</a></li><li class="accordion collapsed child" id=8632760><div class="accordion-heading child"><a href="module-schema.html">schema</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="module-schema.html#.getEnumValues">getEnumValues</a></li><li data-type='method'><a href="module-schema.html#.getReferencedTypes">getReferencedTypes</a></li><li data-type='method'><a href="module-schema.html#.getStructMembers">getStructMembers</a></li><li data-type='method'><a href="module-schema.html#.validateType">validateType</a></li><li data-type='method'><a href="module-schema.html#.validateTypeModel">validateTypeModel</a></li><li data-type='method'><a href="module-schema.html#.validateTypeModelTypes">validateTypeModelTypes</a></li></ul></li></ul> </div></div>
    </nav>
    <div class="navbar-ham" id="navbar-ham">
      <div>
        <div class="first"></div>
        <div class="second"></div>
        <div class="third"></div>
      </div>
    </div>

    <div id="main" class="main-content">
      
      <h1 id='page-title' class="page-title">
        schema-markdown/markdown.js
      </h1>
      

      



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// Licensed under the MIT License
// https://github.com/craigahobbs/schema-markdown/blob/master/LICENSE

/** @module markdown */

import {getBaseURL, isAbsoluteURL} from './elements.js';
import {SchemaMarkdownParser} from './parser.js';
import {validateType} from './schema.js';


// The Mardown model defined as Schema Markdown
const markdownModelSmd = `\
# Markdown document struct
struct Markdown

    # The markdown document's parts
    MarkdownPart[] parts


# Markdown document part struct
union MarkdownPart

    # A paragraph
    Paragraph paragraph

    # A horizontal rule (value is ignored)
    object(nullable) hr

    # A list
    List list

    # A code block
    CodeBlock codeBlock


# Paragraph markdown part struct
struct Paragraph

    # The paragraph style
    optional ParagraphStyle style

    # The paragraph span array
    Span[len > 0] spans


# Paragraph style enum
enum ParagraphStyle
    h1
    h2
    h3
    h4
    h5
    h6


# Paragraph span struct
union Span

    # Text span
    string(len > 0) text

    # Line break (value is ignored)
    object(nullable) br

    # Style span
    StyleSpan style

    # Link span
    LinkSpan link

    # Image span
    ImageSpan image


# Style span struct
struct StyleSpan

    # The span's character style
    CharacterStyle style

    # The contained spans
    Span[len > 0] spans


# Character style enum
enum CharacterStyle
    bold
    italic


# Link span struct
struct LinkSpan

    # The link's URL
    string(len > 0) href

    # The image's title
    optional string(len > 0) title

    # The contained spans
    Span[len > 0] spans


# Image span struct
struct ImageSpan

    # The image URL
    string(len > 0) src

    # The image's alternate text
    string(len > 0) alt

    # The image's title
    optional string(len > 0) title


# List markdown part struct
struct List

    # The list is numbered and this is starting number
    optional int(>= 0) start

    # The list's items
    ListItem[len > 0] items


# List item struct
struct ListItem

    # The markdown document's parts
    MarkdownPart[len > 0] parts


# Code block markdown part struct
struct CodeBlock

    # The code block's language
    optional string(len > 0) language

    # The code block's text lines
    string[] lines
`;


// The Markdown model
export const markdownModel = {
    'title': 'The Markdown Model',
    'types': (new SchemaMarkdownParser(markdownModelSmd)).types
};


/**
 * Generate an element model from a markdown model
 *
 * @param {Object} markdown - The markdown model
 * @param {?string} url - The markdown file's URL
 * @param {?Object} codeBlockLanguages - Optional map of language to code block render function with signature (lines) => elements.
 * @returns {Object[]}
 */
export function markdownElements(markdown, url = null, codeBlockLanguages = null) {
    // Parse the markdown
    const validatedMarkdown = validateType(markdownModel.types, 'Markdown', markdown);

    // Generate an element model from the markdown model parts
    return markdownPartElements(validatedMarkdown.parts, url, codeBlockLanguages);
}


// Helper function to generate an element model from a markdown part model array
function markdownPartElements(parts, url, codeBlockLanguages) {
    const partElements = [];
    for (const markdownPart of parts) {
        // Paragraph?
        /* istanbul ignore else */
        if ('paragraph' in markdownPart) {
            const {paragraph} = markdownPart;
            partElements.push({
                'html': 'style' in paragraph ? paragraph.style : 'p',
                'elem': paragraphSpanElements(paragraph.spans, url)
            });

        // Horizontal rule?
        } else if ('hr' in markdownPart) {
            partElements.push({'html': 'hr'});

        // List?
        } else if ('list' in markdownPart) {
            const {list} = markdownPart;
            partElements.push({
                'html': 'start' in list ? 'ol' : 'ul',
                'attr': 'start' in list &amp;&amp; list.start > 1 ? {'start': `${list.start}`} : null,
                'elem': list.items.map((item) => ({
                    'html': 'li',
                    'elem': markdownPartElements(item.parts, url, codeBlockLanguages)
                }))
            });

        // Code block?
        } else if ('codeBlock' in markdownPart) {
            const {codeBlock} = markdownPart;

            // Render the code block elements
            if (codeBlockLanguages !== null &amp;&amp; 'language' in codeBlock &amp;&amp; codeBlock.language in codeBlockLanguages) {
                partElements.push(codeBlockLanguages[codeBlock.language](codeBlock));
            } else {
                partElements.push(
                    {'html': 'pre', 'elem': {'html': 'code', 'elem': codeBlock.lines.map((line) => ({'text': `${line}\n`}))}}
                );
            }
        }
    }

    return partElements;
}


// Helper function to generate an element model from a markdown span model array
function paragraphSpanElements(spans, url) {
    const spanElements = [];
    for (const span of spans) {
        // Text span?
        /* istanbul ignore else */
        if ('text' in span) {
            spanElements.push({'text': span.text});

        // Line break?
        } else if ('br' in span) {
            spanElements.push({'html': 'br'});

        // Style span?
        } else if ('style' in span) {
            const {style} = span;
            spanElements.push({
                'html': style.style === 'italic' ? 'em' : 'strong',
                'elem': paragraphSpanElements(style.spans, url)
            });

        // Link span?
        } else if ('link' in span) {
            const {link} = span;
            const href = url !== null &amp;&amp; !isAbsoluteURL(link.href) ? `${getBaseURL(url)}${link.href}` : link.href;
            const linkElements = {
                'html': 'a',
                'attr': {'href': href},
                'elem': paragraphSpanElements(link.spans, url)
            };
            if ('title' in link) {
                linkElements.attr.title = link.title;
            }
            spanElements.push(linkElements);

        // Image span?
        } else if ('image' in span) {
            const {image} = span;
            const src = url !== null &amp;&amp; !isAbsoluteURL(image.src) ? `${getBaseURL(url)}${image.src}` : image.src;
            const imageElement = {
                'html': 'img',
                'attr': {'src': src, 'alt': image.alt}
            };
            if ('title' in image) {
                imageElement.attr.title = image.title;
            }
            spanElements.push(imageElement);
        }
    }
    return spanElements;
}


// Markdown regex
const rIndent = /^(?&lt;indent>\s*)(?&lt;notIndent>.*)$/;
const rHeading = /^\s*(?&lt;heading>#{1,6})\s+(?&lt;text>.*?)\s*$/;
const rHeadingAlt = /^\s*(?&lt;heading>=+|-+)\s*$/;
const rHorizontal = /^(?:(?:\s*\*){3,}|(?:\s*-){3,}|(?:\s*_){3,})\s*$/;
const rFenced = /^(?&lt;fence>\s*(?:`{3,}|~{3,}))(?:\s*(?&lt;language>.+?))?\s*$/;
const rList = /^(?&lt;indent>\s*(?&lt;mark>-|\*|\+|[0-9]\.|[1-9][0-9]+\.)\s+)(?&lt;line>.*?)\s*$/;
const rSpans = new RegExp(
    '(?&lt;br>\\s{2}$)|' +
        '(?&lt;link>!?\\[)(?&lt;linkText>[\\s\\S]*?)\\]\\((?&lt;linkHref>[^\\s]+?)(?:\\s*"(?&lt;linkTitle>[\\s\\S]*?)"\\s*)?\\)|' +
        '(?&lt;linkAlt>&lt;)(?&lt;linkAltHref>[[a-z]+:[^\\s]*?)>|' +
        '(?&lt;boldItalic>\\*{3})(?!\\s)(?&lt;boldItalicText>[\\s\\S]*?[^\\s]\\**)\\*{3}|' +
        '(?&lt;bold>\\*{2})(?!\\s)(?&lt;boldText>[\\s\\S]*?[^\\s]\\**)\\*{2}|' +
        '(?&lt;italic>\\*)(?!\\s)(?&lt;italicText>[\\s\\S]*?[^\\s]\\**)\\*',
    'mg'
);
const rEscape = /\\(\\|\*|_|\{|\}|\[|\]|\(|\)|#|\+|-|\.|!)/g;


/**
 * Parse markdown text or text lines into a markdown model
 *
 * @param {string|string[]} markdown - Markdown text or text lines
 * @returns {Object} The markdown model
 */
export function markdownParse(markdown) {
    const markdownParts = [];
    const parts = [[0, null, 0]];
    let paragraph = null;
    let paragraphFenced = null;
    let lines = [];

    // Helper function to add a markdown part
    const addPart = (part) => {
        const [, topList] = parts[parts.length - 1];
        if (topList !== null) {
            const {items} = topList.list;
            items[items.length - 1].parts.push(part);
        } else {
            markdownParts.push(part);
        }
    };

    // Helper function to close the current part
    const closeParagraph = (paragraphStyle = null) => {
        // Code block?
        if (paragraph !== null) {
            // Strip trailing blank lines
            let ixLine;
            for (ixLine = lines.length - 1; ixLine >= 0; ixLine--) {
                if (lines[ixLine] !== '') {
                    break;
                }
            }
            paragraph.codeBlock.lines = lines.splice(0, ixLine + 1);
            paragraph = null;
            paragraphFenced = null;
        } else if (lines.length) {
            // Paragraph
            const paragraphPart = {'paragraph': {'spans': paragraphSpans(lines.join('\n'))}};
            if (paragraphStyle !== null) {
                paragraphPart.paragraph.style = paragraphStyle;
            }
            addPart(paragraphPart);
        }
        lines = [];
    };

    // Helper function to get the correct [indent, list, listIndent] tuple for the given indent
    const updateParts = (indent, isList = false) => {
        // Find the part with the lesser or equal indent
        for (let ixPart = parts.length - 1; ixPart > 0; ixPart--) {
            const [curIndent,, curListIndent] = parts[ixPart];
            if (indent >= (isList ? curListIndent : curIndent)) {
                break;
            }
            parts.pop();
        }
        return parts[parts.length - 1];
    };

    // Helper function to add a paragraph line
    const addLine = (line, lineIndent, codeBlockIndent) => {
        if (lines.length) {
            // Code block line? If so, trip the indent
            if (paragraph !== null) {
                lines.push(line.slice(codeBlockIndent));
            } else {
                lines.push(line);
            }
        } else {
            const [curIndent] = updateParts(lineIndent);
            lines.push(line.slice(curIndent));
        }
    };

    // Process markdown text line by line
    for (const markdownString of (typeof markdown === 'string' ? [markdown] : markdown)) {
        for (const line of markdownString.split('\n')) {
            const matchLine = line.match(rIndent);
            const lineIndent = matchLine.groups.indent.length;
            const emptyLine = matchLine.groups.notIndent === '';
            const matchHeading = emptyLine ? null : line.match(rHeading);
            const matchHeadingAlt = emptyLine ? null : line.match(rHeadingAlt);
            const matchFenced = emptyLine ? null : line.match(rFenced);
            const matchList = emptyLine ? null : line.match(rList);
            const [topIndent] = parts[parts.length - 1];
            const codeBlockIndent = topIndent + 4;

            // Empty line?
            if (emptyLine) {
                // Close any open paragraph
                if (paragraph !== null) {
                    addLine(line, lineIndent, topIndent);
                } else {
                    closeParagraph();
                }

            // Code block start?
            } else if (!lines.length &amp;&amp; lineIndent >= codeBlockIndent) {
                // Add the code block part
                paragraph = {'codeBlock': {}};
                addPart(paragraph);
                lines.push(line.slice(codeBlockIndent));

            // Fenced code start?
            } else if (paragraphFenced === null &amp;&amp; matchFenced !== null &amp;&amp; lineIndent &lt; codeBlockIndent) {
                // Close any open paragraph
                closeParagraph();

                // Add the code block part
                paragraph = {'codeBlock': {}};
                if (typeof matchFenced.groups.language !== 'undefined') {
                    paragraph.codeBlock.language = matchFenced.groups.language;
                }
                paragraphFenced = matchFenced.groups.fence;
                addPart(paragraph);

            // Fenced code end?
            } else if (paragraphFenced !== null &amp;&amp; matchFenced !== null &amp;&amp; paragraphFenced.startsWith(matchFenced.groups.fence) &amp;&amp;
                       typeof matchFenced.groups.language === 'undefined') {
                // Close the code block
                closeParagraph();

            // Fenced code line?
            } else if (paragraphFenced !== null &amp;&amp; matchFenced === null) {
                // Add the code line
                addLine(line, lineIndent, topIndent);

            // Heading?
            } else if (matchHeading !== null &amp;&amp; lineIndent &lt; codeBlockIndent) {
                // Close any open paragraph
                closeParagraph();

                // Add the heading paragraph markdown part
                updateParts(lineIndent);
                lines = [matchHeading.groups.text];
                closeParagraph(`h${matchHeading.groups.heading.length}`);

            // Heading (alternate syntax)?
            } else if (matchHeadingAlt !== null &amp;&amp; lineIndent &lt; codeBlockIndent &amp;&amp; parts.length === 1 &amp;&amp;
                       lines.length &amp;&amp; paragraph === null) {
                // Add the heading paragraph markdown part
                closeParagraph(matchHeadingAlt.groups.heading.startsWith('=') ? 'h1' : 'h2');

            // Horizontal rule?
            } else if (rHorizontal.test(line) &amp;&amp; lineIndent &lt; codeBlockIndent) {
                // Close any open paragraph
                closeParagraph();

                // Add the heading paragraph markdown part
                updateParts(lineIndent);
                addPart({'hr': null});

            // List?
            } else if (matchList !== null &amp;&amp; lineIndent &lt; codeBlockIndent) {
                // Close any open paragraph
                closeParagraph();

                // New list?
                const [curIndent, curList] = updateParts(lineIndent, true);
                if (curList === null || lineIndent >= curIndent) {
                    // Add the new list part
                    const list = {'list': {'items': [{'parts': []}]}};
                    const start = parseInt(matchList.groups.mark, 10);
                    if (!isNaN(start)) {
                        list.list.start = start;
                    }
                    addPart(list);
                    parts.push([matchList.groups.indent.length, list, lineIndent]);
                } else {
                    // Push the new list item
                    const listItem = {'parts': []};
                    curList.list.items.push(listItem);
                }

                // Add the text line
                lines.push(matchList.groups.line);

            // Text line
            } else {
                // End code block first?
                if (paragraph !== null &amp;&amp; lineIndent &lt; codeBlockIndent) {
                    closeParagraph();
                }

                // Add the paragraph line
                addLine(line, lineIndent, codeBlockIndent);
            }
        }
    }

    // Close any open paragraph
    closeParagraph();

    return {'parts': markdownParts};
}


// Helper function to remove escapes from a string
function removeEscapes(text) {
    return text.replace(rEscape, '$1');
}


// Helper function to translate markdown paragraph text to a markdown paragraph span model array
function paragraphSpans(text) {
    const spans = [];

    // Iterate the span matches
    let ixSearch = 0;
    for (const match of text.matchAll(rSpans)) {
        // Add any preceding text
        if (ixSearch &lt; match.index) {
            spans.push({'text': removeEscapes(text.slice(ixSearch, match.index))});
        }


        // Line break?
        /* istanbul ignore else */
        if (typeof match.groups.br !== 'undefined') {
            spans.push({'br': null});

        // Link span?
        } else if (match.groups.link === '[') {
            const span = {'link': {'href': removeEscapes(match.groups.linkHref), 'spans': paragraphSpans(match.groups.linkText)}};
            if (typeof match.groups.linkTitle !== 'undefined') {
                span.link.title = removeEscapes(match.groups.linkTitle);
            }
            spans.push(span);

        // Link span (alternate syntax)?
        } else if (match.groups.linkAlt === '&lt;') {
            spans.push({'link': {'href': removeEscapes(match.groups.linkAltHref), 'spans': paragraphSpans(match.groups.linkAltHref)}});

        // Image span?
        } else if (match.groups.link === '![') {
            const span = {'image': {'src': removeEscapes(match.groups.linkHref), 'alt': removeEscapes(match.groups.linkText)}};
            if (typeof match.groups.linkTitle !== 'undefined') {
                span.image.title = removeEscapes(match.groups.linkTitle);
            }
            spans.push(span);

        // Bold-italic style-span
        } else if (match.groups.boldItalic === '***') {
            spans.push({'style': {'style': 'bold', 'spans': [
                {'style': {'style': 'italic', 'spans': paragraphSpans(match.groups.boldItalicText)}}
            ]}});

        // Bold style-span
        } else if (match.groups.bold === '**') {
            spans.push({'style': {'style': 'bold', 'spans': paragraphSpans(match.groups.boldText)}});

        // Italic style-span
        } else if (match.groups.italic === '*') {
            spans.push({'style': {'style': 'italic', 'spans': paragraphSpans(match.groups.italicText)}});
        }

        ixSearch = match.index + match[0].length;
    }

    // Add any remaining text
    if (ixSearch &lt; text.length) {
        spans.push({'text': removeEscapes(text.slice(ixSearch))});
    }

    return spans;
}
</code></pre>
        </article>
    </section>




    </div>

    <footer class="footer" id="footer">
      
    </footer>

    <script src="scripts/third-party/prettify.js"></script>
    <script src="scripts/third-party/lang-css.js"></script>
    <script src="scripts/search.js"></script>
    <script src="scripts/third-party/fuse.js"></script>
    <script type="text/javascript" src="scripts/misc.js"></script>

    <script>prettyPrint();</script>
    <script src="scripts/linenumber.js"></script>
    <script src="scripts/fix-code-block.js"></script>
    <script src="scripts/fix-navbar.js"></script>
    <script>
      var list = [{"title":"UserTypeElements","link":"<a href=\"module-doc.UserTypeElements.html\">UserTypeElements</a>"},{"title":"module:doc.UserTypeElements.getUrlNoteElements","link":"<a href=\"module-doc.UserTypeElements.html#.getUrlNoteElements\">module:doc.UserTypeElements.getUrlNoteElements &rtrif; undefined</a>"},{"title":"module:doc.UserTypeElements.markdownElem","link":"<a href=\"module-doc.UserTypeElements.html#.markdownElem\">module:doc.UserTypeElements.markdownElem &rtrif; undefined</a>"},{"title":"module:doc.UserTypeElements#getElements","link":"<a href=\"module-doc.UserTypeElements.html#getElements\">module:doc.UserTypeElements &rtrif; getElements</a>"},{"title":"SchemaMarkdownParser","link":"<a href=\"module-parser.SchemaMarkdownParser.html\">SchemaMarkdownParser</a>"},{"title":"module:parser.SchemaMarkdownParser#finalize","link":"<a href=\"module-parser.SchemaMarkdownParser.html#finalize\">module:parser.SchemaMarkdownParser &rtrif; finalize</a>"},{"title":"module:parser.SchemaMarkdownParser#parse","link":"<a href=\"module-parser.SchemaMarkdownParser.html#parse\">module:parser.SchemaMarkdownParser &rtrif; parse</a>"},{"title":"module:parser.SchemaMarkdownParser#parseString","link":"<a href=\"module-parser.SchemaMarkdownParser.html#parseString\">module:parser.SchemaMarkdownParser &rtrif; parseString</a>"},{"title":"SchemaMarkdownParserError","link":"<a href=\"module-parser-SchemaMarkdownParserError.html\">SchemaMarkdownParserError</a>"},{"title":"doc","link":"<a href=\"module-doc.html\">doc</a>"},{"title":"elements","link":"<a href=\"module-elements.html\">elements</a>"},{"title":"module:elements.getBaseURL","link":"<a href=\"module-elements.html#.getBaseURL\">module:elements.getBaseURL &rtrif; undefined</a>"},{"title":"module:elements.isAbsoluteURL","link":"<a href=\"module-elements.html#.isAbsoluteURL\">module:elements.isAbsoluteURL &rtrif; undefined</a>"},{"title":"module:elements.renderElements","link":"<a href=\"module-elements.html#.renderElements\">module:elements.renderElements &rtrif; undefined</a>"},{"title":"module:elements.validateElements","link":"<a href=\"module-elements.html#.validateElements\">module:elements.validateElements &rtrif; undefined</a>"},{"title":"encode","link":"<a href=\"module-encode.html\">encode</a>"},{"title":"module:encode.decodeQueryString","link":"<a href=\"module-encode.html#.decodeQueryString\">module:encode.decodeQueryString &rtrif; undefined</a>"},{"title":"module:encode.encodeHref","link":"<a href=\"module-encode.html#.encodeHref\">module:encode.encodeHref &rtrif; undefined</a>"},{"title":"module:encode.encodeQueryString","link":"<a href=\"module-encode.html#.encodeQueryString\">module:encode.encodeQueryString &rtrif; undefined</a>"},{"title":"markdown","link":"<a href=\"module-markdown.html\">markdown</a>"},{"title":"module:markdown.markdownElements","link":"<a href=\"module-markdown.html#.markdownElements\">module:markdown.markdownElements &rtrif; undefined</a>"},{"title":"module:markdown.markdownParse","link":"<a href=\"module-markdown.html#.markdownParse\">module:markdown.markdownParse &rtrif; undefined</a>"},{"title":"parser","link":"<a href=\"module-parser.html\">parser</a>"},{"title":"schema","link":"<a href=\"module-schema.html\">schema</a>"},{"title":"module:schema.getEnumValues","link":"<a href=\"module-schema.html#.getEnumValues\">module:schema.getEnumValues &rtrif; undefined</a>"},{"title":"module:schema.getReferencedTypes","link":"<a href=\"module-schema.html#.getReferencedTypes\">module:schema.getReferencedTypes &rtrif; undefined</a>"},{"title":"module:schema.getStructMembers","link":"<a href=\"module-schema.html#.getStructMembers\">module:schema.getStructMembers &rtrif; undefined</a>"},{"title":"module:schema.validateType","link":"<a href=\"module-schema.html#.validateType\">module:schema.validateType &rtrif; undefined</a>"},{"title":"module:schema.validateTypeModel","link":"<a href=\"module-schema.html#.validateTypeModel\">module:schema.validateTypeModel &rtrif; undefined</a>"},{"title":"module:schema.validateTypeModelTypes","link":"<a href=\"module-schema.html#.validateTypeModelTypes\">module:schema.validateTypeModelTypes &rtrif; undefined</a>"}];
      var options = 
        setupSearch(list, options)
    </script>

    

    

    


  </body>

</html>