<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Adding meta -->
    

    <!-- Adding external script-->
    

    <!-- Adding external style-->
    

    <!-- Adding scripts-->
    

    <!-- Adding style-->
    

    <!-- Adding overlay script-->
    

    <!-- Adding overlay style-->
    


    <title>
      schema-markdown/schema.js
    </title>

    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/third-party/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/third-party/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/reset.css">
    <link type="text/css" rel="stylesheet" href="styles/heading.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-base.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-light.css">
    
    <svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
    style="display:none">
    <defs>
        <symbol id="copy-icon" viewbox="0 0 488.3 488.3">
            <g>
                <path
                    d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z" />
                <path
                    d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z" />
            </g>
        </symbol>
        <symbol id='search-icon' viewBox="0 0 512 512">
            <g>
                <g>
                    <path
                        d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z" />
                </g>
            </g>
            <g>
                <g>
                    <path
                        d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z" />
                </g>
            </g>
        </symbol>
        <symbol id="down-icon" viewBox="0 0 16 16">
            <path 
                fill-rule="evenodd" 
                clip-rule="evenodd" 
                d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"
            >
            </path>
        </symbol>
    </defs>
</svg>
  </head>

  <body>

    <nav class="navbar" id="navbar">
      <div class="navbar-heading" id="navbar-heading"><a href="index.html"><h2 class="navbar-heading-text">Home</h2></a></div><div class="search-box" id="search-box"><div class="search-box-input-container"><input class="search-box-input" type="text" placeholder="Search..." id="search-box-input" /><svg class="search-icon" alt="search-icon"><use xlink:href="#search-icon"></use></svg></div><div class="search-item-container" id="search-item-container"><ul class="search-item-ul" id="search-item-ul"></ul></div></div><div class="sidebar-main-content" id="sidebar-main-content"><ul><li class="menu-li"><a href='doc#name=TypeModel' class=' menu-link' id='' target=''>Type Model</a></li></ul><div class="accordion collapsed" id="549282" > <h3 class="accordion-heading">Classes<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion collapsed child" id=3043904><div class="accordion-heading child"><a href="module-doc.UserTypeElements.html">UserTypeElements</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="module-doc.UserTypeElements.html#.getUrlNoteElements">getUrlNoteElements</a></li><li data-type='method'><a href="module-doc.UserTypeElements.html#.markdownElem">markdownElem</a></li><li data-type='method'><a href="module-doc.UserTypeElements.html#getElements">getElements</a></li></ul></li><li class="accordion collapsed child" id=2192030><div class="accordion-heading child"><a href="module-parser.SchemaMarkdownParser.html">SchemaMarkdownParser</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="module-parser.SchemaMarkdownParser.html#finalize">finalize</a></li><li data-type='method'><a href="module-parser.SchemaMarkdownParser.html#parse">parse</a></li><li data-type='method'><a href="module-parser.SchemaMarkdownParser.html#parseString">parseString</a></li></ul></li><li class="accordion-list" id=""><a href="module-parser-SchemaMarkdownParserError.html">SchemaMarkdownParserError</a></li></ul> </div><div class="accordion collapsed" id="6400196" > <h3 class="accordion-heading">Modules<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion-list" id=""><a href="module-doc.html">doc</a></li><li class="accordion collapsed child" id=9633893><div class="accordion-heading child"><a href="module-elements.html">elements</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="module-elements.html#.getBaseURL">getBaseURL</a></li><li data-type='method'><a href="module-elements.html#.isAbsoluteURL">isAbsoluteURL</a></li><li data-type='method'><a href="module-elements.html#.renderElements">renderElements</a></li><li data-type='method'><a href="module-elements.html#.validateElements">validateElements</a></li></ul></li><li class="accordion collapsed child" id=4442406><div class="accordion-heading child"><a href="module-encode.html">encode</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="module-encode.html#.decodeQueryString">decodeQueryString</a></li><li data-type='method'><a href="module-encode.html#.encodeHref">encodeHref</a></li><li data-type='method'><a href="module-encode.html#.encodeQueryString">encodeQueryString</a></li></ul></li><li class="accordion collapsed child" id=3944399><div class="accordion-heading child"><a href="module-markdown.html">markdown</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="module-markdown.html#.markdownElements">markdownElements</a></li><li data-type='method'><a href="module-markdown.html#.markdownParse">markdownParse</a></li></ul></li><li class="accordion-list" id=""><a href="module-parser.html">parser</a></li><li class="accordion collapsed child" id=8632760><div class="accordion-heading child"><a href="module-schema.html">schema</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="module-schema.html#.getEnumValues">getEnumValues</a></li><li data-type='method'><a href="module-schema.html#.getReferencedTypes">getReferencedTypes</a></li><li data-type='method'><a href="module-schema.html#.getStructMembers">getStructMembers</a></li><li data-type='method'><a href="module-schema.html#.validateType">validateType</a></li><li data-type='method'><a href="module-schema.html#.validateTypeModel">validateTypeModel</a></li><li data-type='method'><a href="module-schema.html#.validateTypeModelTypes">validateTypeModelTypes</a></li></ul></li></ul> </div></div>
    </nav>
    <div class="navbar-ham" id="navbar-ham">
      <div>
        <div class="first"></div>
        <div class="second"></div>
        <div class="third"></div>
      </div>
    </div>

    <div id="main" class="main-content">
      
      <h1 id='page-title' class="page-title">
        schema-markdown/schema.js
      </h1>
      

      



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// Licensed under the MIT License
// https://github.com/craigahobbs/schema-markdown/blob/master/LICENSE

/** @module schema */

import {typeModel} from './typeModel.js';
import {validateTypeModelTypesErrors} from './schemaUtil.js';


/**
 * Get a user type's referenced type model
 *
 * @param {Object} types - The map of user type name to user type model
 * @param {string} typeName - The type name
 * @param {Object} [referencedTypes=null] - Optional map of referenced user type name to user type model
 * @returns {Object}
 */
export function getReferencedTypes(types, typeName, referencedTypes = {}) {
    return getReferencedTypesHelper(types, {'user': typeName}, referencedTypes);
}


// eslint-disable-next-line no-unused-vars
function getReferencedTypesHelper(types, type, referencedTypes) {
    // Array?
    if ('array' in type) {
        const {array} = type;
        getReferencedTypesHelper(types, array.type, referencedTypes);

    // Dict?
    } else if ('dict' in type) {
        const {dict} = type;
        getReferencedTypesHelper(types, dict.type, referencedTypes);
        if ('keyType' in dict) {
            getReferencedTypesHelper(types, dict.keyType, referencedTypes);
        }

    // User type?
    } else if ('user' in type) {
        const typeName = type.user;

        // Already encountered?
        if (!(typeName in referencedTypes)) {
            const userType = types[typeName];
            referencedTypes[typeName] = userType;

            // Struct?
            /* istanbul ignore else */
            if ('struct' in userType) {
                const {struct} = userType;
                if ('bases' in struct) {
                    for (const base of struct.bases) {
                        getReferencedTypesHelper(types, {'user': base}, referencedTypes);
                    }
                }
                for (const member of getStructMembers(types, struct)) {
                    getReferencedTypesHelper(types, member.type, referencedTypes);
                }

            // Enum?
            } else if ('enum' in userType) {
                const enum_ = userType.enum;
                if ('bases' in enum_) {
                    for (const base of enum_.bases) {
                        getReferencedTypesHelper(types, {'user': base}, referencedTypes);
                    }
                }

            // Typedef?
            } else if ('typedef' in userType) {
                const {typedef} = userType;
                getReferencedTypesHelper(types, typedef.type, referencedTypes);

            // Action?
            } else if ('action' in userType) {
                const {action} = userType;
                if ('path' in action) {
                    getReferencedTypesHelper(types, {'user': action.path}, referencedTypes);
                }
                if ('query' in action) {
                    getReferencedTypesHelper(types, {'user': action.query}, referencedTypes);
                }
                if ('input' in action) {
                    getReferencedTypesHelper(types, {'user': action.input}, referencedTypes);
                }
                if ('output' in action) {
                    getReferencedTypesHelper(types, {'user': action.output}, referencedTypes);
                }
                if ('errors' in action) {
                    getReferencedTypesHelper(types, {'user': action.errors}, referencedTypes);
                }
            }
        }
    }

    return referencedTypes;
}


/**
 * Type-validate a value using a user type model. Container values are duplicated since some member types are
 * transformed during validation.
 *
 * @param {Object} types - The map of user type name to user type model
 * @param {string} typeName - The type name
 * @param {Object} value - The value object to validate
 * @param {string} [memberFqn=null] - Optional fully-qualified member name
 * @returns {Object} The validated, transformed value object
 * @throws {Error} Validation error string
 */
export function validateType(types, typeName, value, memberFqn = null) {
    if (!(typeName in types)) {
        throw new Error(`Unknown type '${typeName}'`);
    }
    return validateTypeHelper(types, {'user': typeName}, value, memberFqn);
}


// Regular expressions used by validateTypeHelper
const rDate = /^\d{4}-\d{2}-\d{2}$/;
const rDatetime = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d{3})?(?:Z|[+-]\d{2}:\d{2})$/;


function validateTypeHelper(types, type, value, memberFqn) {
    let valueNew = value;

    // Built-in type?
    if ('builtin' in type) {
        const {builtin} = type;

        // string or uuid?
        if (builtin === 'string' || builtin === 'uuid') {
            // Not a string?
            if (typeof value !== 'string') {
                throwMemberError(type, value, memberFqn);
            }

            // Not a valid UUID?
            if (builtin === 'uuid' &amp;&amp; !value.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-5][0-9a-f]{3}-[089ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
                throwMemberError(type, value, memberFqn);
            }

        // int or float?
        } else if (builtin === 'int' || builtin === 'float') {
            // Convert string?
            if (typeof value === 'string') {
                if (isNaN(value)) {
                    throwMemberError(type, value, memberFqn);
                }
                valueNew = parseFloat(value);

            // Not a number?
            } else if (typeof value !== 'number') {
                throwMemberError(type, value, memberFqn);

            // Non-int number?
            } else if (builtin === 'int' &amp;&amp; Math.trunc(value) !== value) {
                throwMemberError(type, value, memberFqn);
            }

        // bool?
        } else if (builtin === 'bool') {
            // Convert string?
            if (typeof value === 'string') {
                if (value === 'true') {
                    valueNew = true;
                } else if (value === 'false') {
                    valueNew = false;
                } else {
                    throwMemberError(type, value, memberFqn);
                }

            // Not a bool?
            } else if (typeof value !== 'boolean') {
                throwMemberError(type, value, memberFqn);
            }

        // date or datetime?
        } else if (builtin === 'date' || builtin === 'datetime') {
            // Convert string?
            if (typeof value === 'string') {
                valueNew = new Date(value);
                if (isNaN(valueNew)) {
                    throwMemberError(type, value, memberFqn);
                }

                // Invalid date format?
                if (!(rDate.test(value) || rDatetime.test(value))) {
                    throwMemberError(type, value, memberFqn);
                }

            // Not a date?
            } else if (!(value instanceof Date)) {
                throwMemberError(type, value, memberFqn);
            }

            // For date type, clear hours, minutes, seconds, and milliseconds
            if (builtin === 'date') {
                valueNew = new Date(valueNew.getFullYear(), valueNew.getMonth(), valueNew.getUTCDate());
            }
        }

    // array?
    } else if ('array' in type) {
        // Valid value type?
        const {array} = type;
        const arrayType = array.type;
        const arrayAttr = 'attr' in array ? array.attr : null;
        if (value === '') {
            valueNew = [];
        } else if (!Array.isArray(value)) {
            throwMemberError(type, value, memberFqn);
        }

        // Validate the list contents
        const valueCopy = [];
        const arrayValueNullable = arrayAttr !== null &amp;&amp; 'nullable' in arrayAttr &amp;&amp; arrayAttr.nullable;
        for (let ixArrayValue = 0; ixArrayValue &lt; valueNew.length; ixArrayValue++) {
            const memberFqnValue = memberFqn !== null ? `${memberFqn}.${ixArrayValue}` : `${ixArrayValue}`;
            let arrayValue = valueNew[ixArrayValue];
            if (arrayValue === null || (arrayValueNullable &amp;&amp; arrayValue === 'null')) {
                arrayValue = null;
            } else {
                arrayValue = validateTypeHelper(types, arrayType, arrayValue, memberFqnValue);
            }
            validateAttr(arrayType, arrayAttr, arrayValue, memberFqnValue);
            valueCopy.push(arrayValue);
        }

        // Return the validated, transformed copy
        valueNew = valueCopy;

    // dict?
    } else if ('dict' in type) {
        // Valid value type?
        const {dict} = type;
        const dictType = dict.type;
        const dictAttr = 'attr' in dict ? dict.attr : null;
        const dictKeyType = 'keyType' in dict ? dict.keyType : {'builtin': 'string'};
        const dictKeyAttr = 'keyAttr' in dict ? dict.keyAttr : null;
        if (value === '') {
            valueNew = {};
        } else if (typeof value !== 'object') {
            throwMemberError(type, value, memberFqn);
        }

        // Validate the dict key/value pairs
        const valueCopy = valueNew instanceof Map ? new Map() : {};
        const dictKeyNullable = dictKeyAttr !== null &amp;&amp; 'nullable' in dictKeyAttr &amp;&amp; dictKeyAttr.nullable;
        const dictValueNullable = dictAttr !== null &amp;&amp; 'nullable' in dictAttr &amp;&amp; dictAttr.nullable;
        for (let [dictKey, dictValue] of (valueNew instanceof Map ? valueNew.entries() : Object.entries(valueNew))) {
            const memberFqnKey = memberFqn !== null ? `${memberFqn}.${dictKey}` : `${dictKey}`;

            // Validate the key
            if (dictKey === null || (dictKeyNullable &amp;&amp; dictKey === 'null')) {
                dictKey = null;
            } else {
                dictKey = validateTypeHelper(types, dictKeyType, dictKey, memberFqn);
            }
            validateAttr(dictKeyType, dictKeyAttr, dictKey, memberFqn);

            // Validate the value
            if (dictValue === null || (dictValueNullable &amp;&amp; dictValue === 'null')) {
                dictValue = null;
            } else {
                dictValue = validateTypeHelper(types, dictType, dictValue, memberFqnKey);
            }
            validateAttr(dictType, dictAttr, dictValue, memberFqnKey);

            // Copy the key/value
            if (valueCopy instanceof Map) {
                valueCopy.set(dictKey, dictValue);
            } else {
                valueCopy[dictKey] = dictValue;
            }
        }

        // Return the validated, transformed copy
        valueNew = valueCopy;

    // User type?
    } else if ('user' in type) {
        const userType = types[type.user];

        // action?
        if ('action' in userType) {
            throwMemberError(type, value, memberFqn);
        }

        // typedef?
        if ('typedef' in userType) {
            const {typedef} = userType;
            const typedefAttr = 'attr' in typedef ? typedef.attr : null;

            // Validate the value
            const valueNullable = typedefAttr !== null &amp;&amp; 'nullable' in typedefAttr &amp;&amp; typedefAttr.nullable;
            if (value === null || (valueNullable &amp;&amp; value === 'null')) {
                valueNew = null;
            } else {
                valueNew = validateTypeHelper(types, typedef.type, value, memberFqn);
            }
            validateAttr(type, typedefAttr, valueNew, memberFqn);

        // enum?
        } else if ('enum' in userType) {
            const enum_ = userType.enum;

            // Not a valid enum value?
            if (!getEnumValues(types, enum_).some((enumValue) => value === enumValue.name)) {
                throwMemberError(type, value, memberFqn);
            }

        // struct?
        } else if ('struct' in userType) {
            const {struct} = userType;

            // Valid value type?
            if (value === '') {
                valueNew = {};
            } else if (typeof value !== 'object') {
                throwMemberError({'user': struct.name}, value, memberFqn);
            }

            // Valid union?
            const isUnion = 'union' in struct ? struct.union : false;
            if (isUnion) {
                if (Object.keys(value).length !== 1) {
                    throwMemberError({'user': struct.name}, value, memberFqn);
                }
            }

            // Validate the struct members
            const valueCopy = valueNew instanceof Map ? new Map() : {};
            for (const member of getStructMembers(types, struct)) {
                const memberName = member.name;
                const memberFqnMember = memberFqn !== null ? `${memberFqn}.${memberName}` : `${memberName}`;
                const memberOptional = 'optional' in member ? member.optional : false;

                // Missing non-optional member?
                if (!(valueNew instanceof Map ? valueNew.has(memberName) : memberName in valueNew)) {
                    if (!memberOptional &amp;&amp; !isUnion) {
                        throw new Error(`Required member '${memberFqnMember}' missing`);
                    }
                } else {
                    // Validate the member value
                    let memberValue = valueNew instanceof Map ? valueNew.get(memberName) : valueNew[memberName];
                    if (memberValue !== null) {
                        memberValue = validateTypeHelper(types, member.type, memberValue, memberFqnMember);
                    }
                    validateAttr(member.type, 'attr' in member ? member.attr : null, memberValue, memberFqnMember);

                    // Copy the validated member
                    if (valueCopy instanceof Map) {
                        valueCopy.set(memberName, memberValue);
                    } else {
                        valueCopy[memberName] = memberValue;
                    }
                }
            }

            // Any unknown members?
            const valueCopyKeys = valueCopy instanceof Map ? Array.from(valueCopy.keys()) : Object.keys(valueCopy);
            const valueNewKeys = valueNew instanceof Map ? Array.from(valueNew.keys()) : Object.keys(valueNew);
            if (valueCopyKeys.length !== valueNewKeys.length) {
                const memberSet = new Set(getStructMembers(types, struct).map((member) => member.name));
                const [unknownKey] = valueNewKeys.filter((key) => !memberSet.has(key));
                const unknownFqn = memberFqn !== null ? `${memberFqn}.${unknownKey}` : `${unknownKey}`;
                throw new Error(`Unknown member '${unknownFqn.slice(0, 100)}'`);
            }

            // Return the validated, transformed copy
            valueNew = valueCopy;
        }
    }

    return valueNew;
}


function throwMemberError(type, value, memberFqn, attr = null) {
    const memberPart = memberFqn !== null ? ` for member '${memberFqn}'` : '';
    const typeName = 'builtin' in type ? type.builtin : ('array' in type ? 'array' : ('dict' in type ? 'dict' : type.user));
    const attrPart = attr !== null ? ` [${attr}]` : '';
    const valueStr = `${JSON.stringify(value)}`;
    const msg = `Invalid value ${valueStr.slice(0, 100)} (type '${typeof value}')${memberPart}, expected type '${typeName}'${attrPart}`;
    throw new Error(msg);
}


function validateAttr(type, attr, value, memberFqn) {
    if (value === null) {
        const valueNullable = attr !== null &amp;&amp; 'nullable' in attr &amp;&amp; attr.nullable;
        if (!valueNullable) {
            throwMemberError(type, value, memberFqn);
        }
    } else if (attr !== null) {
        const length = Array.isArray(value) || typeof value === 'string' ? value.length
            : (typeof value === 'object' ? Object.keys(value).length : null);

        if ('eq' in attr &amp;&amp; !(value === attr.eq)) {
            throwMemberError(type, value, memberFqn, `== ${attr.eq}`);
        }
        if ('lt' in attr &amp;&amp; !(value &lt; attr.lt)) {
            throwMemberError(type, value, memberFqn, `&lt; ${attr.lt}`);
        }
        if ('lte' in attr &amp;&amp; !(value &lt;= attr.lte)) {
            throwMemberError(type, value, memberFqn, `&lt;= ${attr.lte}`);
        }
        if ('gt' in attr &amp;&amp; !(value > attr.gt)) {
            throwMemberError(type, value, memberFqn, `> ${attr.gt}`);
        }
        if ('gte' in attr &amp;&amp; !(value >= attr.gte)) {
            throwMemberError(type, value, memberFqn, `>= ${attr.gte}`);
        }
        if ('lenEq' in attr &amp;&amp; !(length === attr.lenEq)) {
            throwMemberError(type, value, memberFqn, `len == ${attr.lenEq}`);
        }
        if ('lenLT' in attr &amp;&amp; !(length &lt; attr.lenLT)) {
            throwMemberError(type, value, memberFqn, `len &lt; ${attr.lenLT}`);
        }
        if ('lenLTE' in attr &amp;&amp; !(length &lt;= attr.lenLTE)) {
            throwMemberError(type, value, memberFqn, `len &lt;= ${attr.lenLTE}`);
        }
        if ('lenGT' in attr &amp;&amp; !(length > attr.lenGT)) {
            throwMemberError(type, value, memberFqn, `len > ${attr.lenGT}`);
        }
        if ('lenGTE' in attr &amp;&amp; !(length >= attr.lenGTE)) {
            throwMemberError(type, value, memberFqn, `len >= ${attr.lenGTE}`);
        }
    }
}


/**
 * Get the struct's members (inherited members first)
 *
 * @param {Object} types - The map of user type name to user type model
 * @param {Object} struct - The struct model
 * @returns {Array&lt;Object>} The array of struct member models
 */
export function getStructMembers(types, struct) {
    // No base structs?
    if (!('bases' in struct)) {
        return 'members' in struct ? struct.members : [];
    }

    // Get base struct members
    const members = [];
    for (const base of struct.bases) {
        let baseUserType = types[base];
        while ('typedef' in baseUserType) {
            baseUserType = types[baseUserType.typedef.type.user];
        }
        members.push(...getStructMembers(types, baseUserType.struct));
    }

    // Add struct members
    if ('members' in struct) {
        members.push(...struct.members);
    }

    return members;
}


/**
 * Get the enum's values (inherited values first)
 *
 * @param {Object} types - The map of user type name to user type model
 * @param {Object} enum_ - The enum model
 * @returns {Array&lt;Object>} The array of enum value models
 */
export function getEnumValues(types, enum_) {
    // No base enums?
    if (!('bases' in enum_)) {
        return 'values' in enum_ ? enum_.values : [];
    }

    // Get base enum values
    const values = [];
    for (const base of enum_.bases) {
        let baseUserType = types[base];
        while ('typedef' in baseUserType) {
            baseUserType = types[baseUserType.typedef.type.user];
        }
        values.push(...getEnumValues(types, baseUserType.enum));
    }

    // Add enum values
    if ('values' in enum_) {
        values.push(...enum_.values);
    }

    return values;
}


/**
 * Validate a type model's types object
 *
 * @param {Object} types - The map of user type name to user type model
 * @returns {Object} The validated, transformed types object
 */
export function validateTypeModelTypes(types) {
    // Validate with the type model
    const validatedTypes = validateType(typeModel.types, 'Types', types);

    // Do additional type model validation
    const errors = validateTypeModelTypesErrors(validatedTypes);
    if (errors.length) {
        throw new Error(errors.map(([,, message]) => message).join('\n'));
    }

    return validatedTypes;
}


/**
 * Validate a user type model
 *
 * @param {Object} userTypeModel - The user type model
 * @returns {Object} The validated, transformed type model
 */
export function validateTypeModel(userTypeModel) {
    // Validate with the type model
    const validatedUserTypeModel = validateType(typeModel.types, 'TypeModel', userTypeModel);

    // Do additional type model validation
    const errors = validateTypeModelTypesErrors(validatedUserTypeModel.types);
    if (errors.length) {
        throw new Error(errors.map(([,, message]) => message).join('\n'));
    }

    return validatedUserTypeModel;
}
</code></pre>
        </article>
    </section>




    </div>

    <footer class="footer" id="footer">
      
    </footer>

    <script src="scripts/third-party/prettify.js"></script>
    <script src="scripts/third-party/lang-css.js"></script>
    <script src="scripts/search.js"></script>
    <script src="scripts/third-party/fuse.js"></script>
    <script type="text/javascript" src="scripts/misc.js"></script>

    <script>prettyPrint();</script>
    <script src="scripts/linenumber.js"></script>
    <script src="scripts/fix-code-block.js"></script>
    <script src="scripts/fix-navbar.js"></script>
    <script>
      var list = [{"title":"UserTypeElements","link":"<a href=\"module-doc.UserTypeElements.html\">UserTypeElements</a>"},{"title":"module:doc.UserTypeElements.getUrlNoteElements","link":"<a href=\"module-doc.UserTypeElements.html#.getUrlNoteElements\">module:doc.UserTypeElements.getUrlNoteElements &rtrif; undefined</a>"},{"title":"module:doc.UserTypeElements.markdownElem","link":"<a href=\"module-doc.UserTypeElements.html#.markdownElem\">module:doc.UserTypeElements.markdownElem &rtrif; undefined</a>"},{"title":"module:doc.UserTypeElements#getElements","link":"<a href=\"module-doc.UserTypeElements.html#getElements\">module:doc.UserTypeElements &rtrif; getElements</a>"},{"title":"SchemaMarkdownParser","link":"<a href=\"module-parser.SchemaMarkdownParser.html\">SchemaMarkdownParser</a>"},{"title":"module:parser.SchemaMarkdownParser#finalize","link":"<a href=\"module-parser.SchemaMarkdownParser.html#finalize\">module:parser.SchemaMarkdownParser &rtrif; finalize</a>"},{"title":"module:parser.SchemaMarkdownParser#parse","link":"<a href=\"module-parser.SchemaMarkdownParser.html#parse\">module:parser.SchemaMarkdownParser &rtrif; parse</a>"},{"title":"module:parser.SchemaMarkdownParser#parseString","link":"<a href=\"module-parser.SchemaMarkdownParser.html#parseString\">module:parser.SchemaMarkdownParser &rtrif; parseString</a>"},{"title":"SchemaMarkdownParserError","link":"<a href=\"module-parser-SchemaMarkdownParserError.html\">SchemaMarkdownParserError</a>"},{"title":"doc","link":"<a href=\"module-doc.html\">doc</a>"},{"title":"elements","link":"<a href=\"module-elements.html\">elements</a>"},{"title":"module:elements.getBaseURL","link":"<a href=\"module-elements.html#.getBaseURL\">module:elements.getBaseURL &rtrif; undefined</a>"},{"title":"module:elements.isAbsoluteURL","link":"<a href=\"module-elements.html#.isAbsoluteURL\">module:elements.isAbsoluteURL &rtrif; undefined</a>"},{"title":"module:elements.renderElements","link":"<a href=\"module-elements.html#.renderElements\">module:elements.renderElements &rtrif; undefined</a>"},{"title":"module:elements.validateElements","link":"<a href=\"module-elements.html#.validateElements\">module:elements.validateElements &rtrif; undefined</a>"},{"title":"encode","link":"<a href=\"module-encode.html\">encode</a>"},{"title":"module:encode.decodeQueryString","link":"<a href=\"module-encode.html#.decodeQueryString\">module:encode.decodeQueryString &rtrif; undefined</a>"},{"title":"module:encode.encodeHref","link":"<a href=\"module-encode.html#.encodeHref\">module:encode.encodeHref &rtrif; undefined</a>"},{"title":"module:encode.encodeQueryString","link":"<a href=\"module-encode.html#.encodeQueryString\">module:encode.encodeQueryString &rtrif; undefined</a>"},{"title":"markdown","link":"<a href=\"module-markdown.html\">markdown</a>"},{"title":"module:markdown.markdownElements","link":"<a href=\"module-markdown.html#.markdownElements\">module:markdown.markdownElements &rtrif; undefined</a>"},{"title":"module:markdown.markdownParse","link":"<a href=\"module-markdown.html#.markdownParse\">module:markdown.markdownParse &rtrif; undefined</a>"},{"title":"parser","link":"<a href=\"module-parser.html\">parser</a>"},{"title":"schema","link":"<a href=\"module-schema.html\">schema</a>"},{"title":"module:schema.getEnumValues","link":"<a href=\"module-schema.html#.getEnumValues\">module:schema.getEnumValues &rtrif; undefined</a>"},{"title":"module:schema.getReferencedTypes","link":"<a href=\"module-schema.html#.getReferencedTypes\">module:schema.getReferencedTypes &rtrif; undefined</a>"},{"title":"module:schema.getStructMembers","link":"<a href=\"module-schema.html#.getStructMembers\">module:schema.getStructMembers &rtrif; undefined</a>"},{"title":"module:schema.validateType","link":"<a href=\"module-schema.html#.validateType\">module:schema.validateType &rtrif; undefined</a>"},{"title":"module:schema.validateTypeModel","link":"<a href=\"module-schema.html#.validateTypeModel\">module:schema.validateTypeModel &rtrif; undefined</a>"},{"title":"module:schema.validateTypeModelTypes","link":"<a href=\"module-schema.html#.validateTypeModelTypes\">module:schema.validateTypeModelTypes &rtrif; undefined</a>"}];
      var options = 
        setupSearch(list, options)
    </script>

    

    

    


  </body>

</html>